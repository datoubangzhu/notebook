<html>
<head>
  <title>1.3多线程锁和支持并发的基础类（类，集合）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600480 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="432"/>
<h1>1.3多线程锁和支持并发的基础类（类，集合）</h1>

<div>
<span><div><div>1.锁分类：从不同的角度可以对锁进行多个分类，比如数据库锁中乐观和悲观锁是处理锁态度上的不同，独占/共享锁处理具体代码逻辑上的锁。</div><div><span style="font-size: 10pt;">在java中，</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal;">Java中的锁有很多概念和术语，如可重入锁、公平锁、偏向锁等。这些术语中，有些指的是同一种锁，有些是表示的锁的特征。如synchronized</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal;">同时是可重入锁、非公平锁、互斥锁等。</span></div><div><a href="https://www.jianshu.com/p/39628e1180a9" style="color: rgb(47, 47, 47);">https://www.jianshu.com/p/39628e1180a9</a></div><div><br/></div><div>1.1.概念上的锁：</div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">(1).乐观锁/悲观锁</span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">乐观锁实现方式：(1)添加版本标识；(2)CAS</span></div><div>a添加标识：读取和写入的时候都带上版本号，规定每次更新一次数据，版本号加1，再次更新的时候，如果携带的版本号不比数据库字段小1，那么说明此时数据已经不是自己修改的了。</div><div><span style="font-size: 13.3333px;">b.悲观锁：采取具体的逻辑加锁方式实现</span></div><ul style="box-sizing: border-box; margin: -5px 0px 0px 20px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-break: break-word !important;"><li style="box-sizing: border-box;"><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">悲观锁和乐观锁并非是一种实际的锁，而是指一种加锁的概念</span></div></li><li><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal;">这种也并非java独有，在其他语言和数据库中都有广泛的应用</span></div></li><li style="box-sizing: border-box;"><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">悲观锁在java中一般指代常见的各种锁</span></div></li><li style="box-sizing: border-box; margin-bottom: 0px;"><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">乐观锁在java中一般指代CAS操作</span></div></li></ul><div>(2)分段锁</div><div>    </div><ul style="box-sizing: border-box; margin: -5px 0px 0px 20px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-break: break-word !important;"><li style="box-sizing: border-box;"><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">分段锁也并非一种实际的锁，而是一种思想</span></div></li><li style="box-sizing: border-box; margin-bottom: 0px;"><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">ConcurrentHashMap是学习分段锁的最好实践</span></div></li></ul><div>(3)互斥锁</div><div><span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial; font-variant-caps: normal; font-variant-ligatures: normal;">保证在任一时刻，只能有一个线程访问该对象。私以为互斥锁与悲观锁概念相似，非互斥锁与乐观锁概念相似； </span></div><div>(4)自旋锁</div><div>和互斥锁相比，一般互斥锁在请求时，如果没有请求到锁，会进入等待队列，然后等待锁释放之后才能拿到锁，但是自旋锁不会进入等待队列，而是不断的重复请求，直到获得锁。</div><ul style="box-sizing: border-box; margin: -5px 0px 0px 20px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-break: break-word !important;"><li style="box-sizing: border-box;"><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">自旋锁是一种思想，一般需要配合CAS使用</span></div></li><li><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal;">java.util.conrurrent.atomic</span><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal;">包下的原子类是自旋锁的很好的实践</span></div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>1.2.逻辑中锁的实现方式</div><div>(1).可重入锁（递归锁）</div><div><span style="font-size: 10pt; color: rgb(51, 51, 51);">不可重入的话，一个锁在嵌套中使用会把自己锁死  </span></div><ul><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51);"> (</span><font style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(51, 51, 51);">synchronized和reentrantlock</span><span style="font-size: 10pt; color: rgb(51, 51, 51);">都是可重入锁，可放心使用)</span></font></div></li></ul><div><span style="color: rgb(51, 51, 51);">(2).公平锁/非公平锁</span></div><div><span style="color: rgb(51, 51, 51);">根据线程申请的等待时间来分配，避免有的线程永远也无法得到运行</span></div><ul><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51);">synchronized是非公平锁，reentrantlock</span><span style="font-size: 10pt; color: rgb(51, 51, 51);">默认构造函数也是非公平锁</span></div></li><li><div><span style="font-size: 10pt; color: rgb(51, 51, 51);">非公平锁的性能比公平锁要高很多，因为公平锁要维护排队的队列；</span><span style="color: rgb(51, 51, 51);">但公平锁比非公平锁的吞吐量大，而且可能导致有线程永远获取不到锁饿死</span></div></li></ul><div><br/></div><div>(3).互斥锁/共享锁</div><div>任何语言中都存在，类比数据库互斥/共享锁</div><div><br/></div><div><br/></div><div>(4)偏向锁/轻量级锁/重量级锁</div><ul style="box-sizing: border-box; margin: -5px 0px 0px 20px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-break: break-word !important;"><li style="box-sizing: border-box;"><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">偏向锁、轻量级锁是针对重量级锁做优化而提出来的概念和实施方案（参考博客：</span><a href="http://www.cnblogs.com/paddix/p/5405678.html" style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">http://www.cnblogs.com/paddix/p/5405678.html</a><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">）</span></div></li><li style="box-sizing: border-box; margin-bottom: 0px;"><div><span style="font-size: 10pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; line-height: 30px;">这些优化大部分情况下对于开发来讲是透明的，默认开启</span></div></li></ul><div><br/></div><div><br/></div><div>1.3多线程问题处理：</div><div>找准“共享资源”，对和共享资源有关所有操作进行处理</div><div><br/></div><div><br/></div><div><br/></div><div>1.4 Lock锁</div><div>lock是一个接口，它有三个实现类，一个是ReentrantLock,另两个是ReentrantReadWriteLock类中的两个静态内部类ReadLock和WriteLock。</div><div>ReentrantLock此处不再介绍。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();</font></div><div><font style="font-size: 10pt;">Lock readLock = reentrantReadWriteLock.readLock(); //开启读锁</font></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);">Lock  writeLock = reentrantReadWriteLock.writeLock();  //开启写锁</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//释放锁</span></div></div><div>     <span style="font-style: italic; font-weight: bold;">参考博客：</span><a href="https://www.cnblogs.com/whatadiors/p/8013086.html" style="font-style: italic; font-weight: bold;">https://www.cnblogs.com/whatadiors/p/8013086.html</a></div><div><br/></div><div><br/></div><div>2.常用锁</div><div>(1) synchronized</div><div>(2)ReentrantLock</div><div>(3) semaphore</div><div>(4)AtomicInteger</div><div><br/></div><div><br/></div><div>2.5死锁与Synchronized、ReentrantLock</div><div>(1)死锁发生条件：</div><div>当前线程拥有其他线程需要的资源；当前线程等待其他线程已拥有的资源；都不放弃自己拥有的资源</div><div>例如：a线程拿到牙膏，上锁，想要牙刷；b线程拿到牙刷，上锁，想要牙膏，这时候a，b线程都会陷入等待中，造成死锁。</div><div>死锁类型：<a href="https://www.cnblogs.com/Java3y/p/8999199.html">https://www.cnblogs.com/Java3y/p/8999199.html</a></div><div><br/></div><div>(2)ReentrantLock与synchronized</div><div><span style="font-size: 10pt; color: rgb(79, 79, 79);"> </span> <span style="font-size: 10pt;">reentrantLock  </span></div><div><span style="font-size: 10pt;">        a.</span><span style="font-size: 10pt;">等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。</span></div><div><span style="text-align: justify;"><span style="font-size: 10pt;">        b.支持公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</span></span></div><div><span style="text-align: justify;"><span style="font-size: 10pt;">synchronized 加锁由jvm处理的。可以自动处理异常（异常时放弃锁），reentrantlock需要手动lock()和unlock()加锁释放锁，用try catch finally处理,通常在finally中加unlock();  一般在加锁之前尝试获得锁 lock.tryLock(1, TimeUnit.SECONDS)，然后再加锁，如果没有获取成功就放弃了。</span></span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 10pt;">3. 集合比较，java</span>线程安全集合记忆，喂（V代表vector），SHE(分别代表stack hashtable Enumeration)</div><div><br/></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-variant-caps: normal; font-variant-ligatures: normal;">(1)HashMap和ConcurrentHashMap，HashTable比较</span></font></div><div><span style="font-size: 13.3333px;">从线程角度来说，hashMap是线程不安全的，ConcurrentHashMap和HashTable是线程安全的</span></div><div><span style="font-size: 13.3333px;">ConcurrentHashMap 分段锁</span></div><div><span style="font-size: 13.3333px;">HashTable synchronized</span></div><div><br/></div><div><span style="font-size: 13.3333px;">(2)Vector和Arraylist,LinkedList比较</span></div><div><span style="font-size: 13.3333px;">从线程角度来说，arraylist和linkedlist是线程不安全的，Vector是线程安全的 </span></div><div><span style="font-size: 13.3333px;">Vector  synchronized</span></div><div><span style="font-size: 13.3333px;"><br/></span></div><ul><li><div><span style="font-size: 13.3333px;">线程安全示例：例如Arraylist，在进行add操作时，会判断是否达到数组最大长度，如果达到了会进行一次扩容。 当有多个线程执行add操作时，可能会造成数组越界。</span><br/></div></li></ul><div><br/></div><div><span style="font-size: 13.3333px;">(3)HashSet和LinkedHashSet，TreeSet</span></div><div>都是线程不安全的</div><div><br/></div><div><a href="https://blog.csdn.net/gldemo/article/details/44653787" style="color: rgb(0, 0, 0);">https://blog.csdn.net/gldemo/article/details/44653787</a></div><div><br/></div><div><br/></div><div>4.StringBuffer和StringBuilder</div><div>StringBuffer线程安全，如何实现的：synchronized</div><div><br/></div><div><br/></div><div>5.单例模式与Spring；线程安全的单例模式</div><div>饿汉</div><div>Demo{</div><div>    private Demo(){}</div><div>    private static final Demo demo = new Demo();</div><div>    public static Demo getInstance(){</div><div>            return demo;</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 