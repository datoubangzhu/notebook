<html>
<head>
  <title>JVM-类加载</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600480 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="423"/>
<h1>JVM-类加载</h1>

<div>
<span><div><div>一、内存划分</div><div><img src="JVM-类加载_files/{28A7964B-FAE4-DD4E-5097-A8D44FBA45E0}.jpg" type="image/jpeg" data-filename="{28A7964B-FAE4-DD4E-5097-A8D44FBA45E0}.jpg"/></div><div><br/></div><div><a href="https://zhidao.baidu.com/question/345439528.html">https://zhidao.baidu.com/question/345439528.html</a></div><div><a href="https://www.cnblogs.com/langtianya/p/4441206.html">https://www.cnblogs.com/langtianya/p/4441206.html</a></div><div>概括为:</div><div>1.方法区存放了</div><ul><li><div>方法的方法名，返回值类型，参数类型，参数顺序</div></li><li><div>静态变量，静态方法</div></li></ul><div>        1.1方法区常量池（1.7开始常量池移入堆内存）</div><div>            .class文件内容结构剖析<a href="https://blog.csdn.net/luanlouis/article/details/40301985">https://blog.csdn.net/luanlouis/article/details/40301985</a></div><div>            jdk1.7各种常量池比较：<a href="https://blog.csdn.net/sugar_rainbow/article/details/68150249">https://blog.csdn.net/sugar_rainbow/article/details/68150249</a></div><div>            常量池分析: <a href="https://blog.csdn.net/zm13007310400/article/details/77534349">https://blog.csdn.net/zm13007310400/article/details/77534349</a></div><div>jdk1.7之前字符串常量池在方法区中（1.7以后字符串常量池移入堆）</div><ul><li><div>代码缓冲区，即JIT编译后的代码都放在这里。</div></li></ul><div>2.堆内存存放了对象，具体为存放对象的成员变量</div><div>3.虚拟机栈内存在方法运行时为每个方法创建栈帧</div><div>4.本地方法为虚拟机用到的Nativa方法服务，与操作系统等进行交互</div><div>5.程序计数器负责保证方法切换运行时能找到准确的位置</div><div><br/></div><div>二、类加载器</div><div> </div><div><b>启动类加载器</b>是虚拟机实现的，其他加载器由虚拟机外部实现。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">双亲委托加载机制</span>：所有的加载器都最终<b>继承</b>自<b>启动类加载器</b>，每次加载之前都判断是否已经加载，并且传递给启动类加载器，判断是否被唯一加载。如果没有，再逐层传递到子类加载器，由子类加载器具体加载。</div><div><br/></div><div>三、类加载</div><ol><li><div>加载    将.class文件加载到内存中</div></li><li><div>验证    文件格式验证（是否以魔术开头），原数据验证（是否继承不被允许继承的类），符号引用验证等</div></li><li><div>准备    给类变量分配内存，赋初值</div></li><li><div>解析    虚拟机常量池内的符号引用替换为直接引用的过程。</div></li></ol><div>例如在Worker类的gotoWork()方法中会引用Car类的run()方法。</div><div>public void gotoWork() {</div><div>        car.run();// 这段代码在Worker类的二进制数据中表示为符号引用</div><div>}</div><div>解析阶段，Java虚拟机会把这个符号引用替换为一个指针，该指针指向Car类的run()方法在方法区内的内存位置，这个指针就是直接引用。</div><ol><li><div>初始化，根据static书写顺序来进行最终赋值或者执行静态代码块</div></li></ol><div><b>说明：类名.class 不会执行static代码块因此可以判断未完成类加载过程。而Class.forName()完成了类加载的全过程</b></div><div><br/></div><div>四、类实例化</div><div>       1.父类成员变量分配内存空间，赋值</div><div>       2.父类构造代码块，构造函数执行 </div><div>       3.子类成员变量分配内存空间，赋值</div><div>       4.子类构造代码块，构造函数执行</div><div>以上场景，当子类继承父类，在子类构造函数第一行显示调用父类构造函数时，根据顺序，先执行父类成员变量分配内存赋值，然后执行父类构造函数，然后此时执行子类成员变量分配内存赋值，然后接着执行完子类构造函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">/**</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">* 实验代码</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">*/</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class C {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    C() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        System.out.print(&quot;C&quot;);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class CR{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    CR(){</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        System.out.println(&quot;CR&quot;);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class A {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    C c = new C();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    A() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        this(&quot;A&quot;);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        System.out.print(&quot;A&quot;);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">     }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    A(String s) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       System.out.print(s);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    }  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public class Example extends A {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    </span><span style="font-family: Monaco; font-size: 9pt;">  CR cr = new CR();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">      Example() {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">            super(&quot;B&quot;);       </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">            System.out.print(&quot;B&quot;);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    public static void main(String[] args) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">      new Example();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    }</span></div><div><span style="font-family: Monaco; font-size: 9pt;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">执行结果：</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">CBCR</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">B</span></div></div><div>        目前所知，在类加载第5部没有完成的时候，也可以实例化，具体体现为饿汉单例模式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public class Demo{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    private static Demo demo = new Demo();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">一篇博客剖析的很好   </span><a href="https://blog.csdn.net/u010106153/article/details/50867402" style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">https://blog.csdn.net/u010106153/article/details/50867402</a></div><div>一个大牛对饿汉单例模式的执行过程总结的很有借鉴价值</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">大致总结下，这个例子中会</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">1. 读取A的class 文件，认证和解析</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">2. 初始化成员A a，给一个指针的空间，附属一个null的默认值</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">3. 准备好alloctMemAndRunConsturctorOfA，并定义其返回值给A（但这时alloctMemAndRunConsturctorOfA并不会执行）</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">4. 类A初始化完毕，得知sizeOf(A)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">5. 运行alloctMemAndRunConsturctorOfA</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">   5.1 分配sizeOf（A）那么大的内存</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">   5.2 运行A的构造函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">   5.3 把地址赋值给a</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">完事</span></div></div><div><br/></div><div>五，字节码执行顺序</div><div>字节码指令解读 <a href="https://www.cnblogs.com/kexianting/p/8523296.html">https://www.cnblogs.com/kexianting/p/8523296.html</a></div><div>注意，在虚拟机中中的数据类型有原始类型和引用类型，原始类型分数值类型，布尔类型，returnAddress类型。值得思考的是，byte,short,boolean,char类型的load，store系列等指令都是由int类型对应指令替代的。这或许可以解释，为什么java里数字可以直接赋值给上面四种数值类型。</div><div><br/></div><div>方法运行时<span style="font-weight: bold;">栈内结构</span>：</div><ul><li><div>局部变量表：大小由编译器决定，方法运行时存储局部变量</div></li><li><div>操作数栈：负责局部变量的运算，比如两个int类型值相加，则对应两个int类型数据入栈，然后出栈计算，然后结果再入操作数栈。</div></li><li><div>动态链接</div></li><li><div>returnAddress</div></li></ul><div><br/></div><div><br/></div><div>六、垃圾回收</div><div><img src="JVM-类加载_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>堆内存是gc管理的主要区域，具体分为新生代和老年代，其中新生代又可分为eden和surivor区，根据对象存活时间和对象大小等进去不同区域，新建对象大多首先进入eden区。</div><div><br/></div><div>java回收算法：</div><ul><li><div>复制算法</div></li><li><div>标记清理算法</div></li></ul><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">两个概念：新生代和年老代</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">新生代：初始对象，生命周期短的</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">永久代：长时间存在的对象</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">P.S：</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Serial New收集器是针对新生代的收集器，采用的是复制算法</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Parallel</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Scavenge（并行）收集器，针对新生代，采用复制收集算法</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Parallel</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Old（并行）收集器，针对老年代，标记整理</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">CMS收集器，基于标记清理</span></div><div style="font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">G1收集器：整体上是基于标记</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">整理</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">，局部采用复制</span></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</span></div><div><br/></div><div><br/></div><div><br/></div><div>七、JVM调参</div><div><span style="font-weight: bold;">-Xss</span> 每个线程的<span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">栈大小</span></div><div><span style="font-weight: bold;">-Xms</span> 初始堆大小</div><div><span style="font-weight: bold;">-Xmx</span> 最大堆大小</div><div><span style="font-weight: bold;">-Xmn</span>2g：设置年轻代大小为2G（<span style="font-weight: bold;">-XX:NewSize</span>和<span style="font-weight: bold;">-XX:MaxNewSize</span>大小相同均为2g）。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</div><div><span style="font-weight: bold;">-XX:NewSize</span>=1024m：设置年轻代初始值为1024M。</div><div><span style="font-weight: bold;">-XX:MaxNewSize</span>=1024m：设置年轻代最大值为1024M。</div><div>（jdk1.7） <span style="font-weight: bold;">-XX:PermSize</span>=64m：—设置永久代(Permanent Space)初始值为64M。</div><div>（jdk1.7） <span style="font-weight: bold;">-XX:MaxPermSize</span>=256m：设置持久代最大值为256M。</div><div>（jdk1.8） <span style="font-weight: bold;">-XX:MaxMetaspaceSize</span> = 256m: 设置元空间最大值为256M。</div><div>（jdk1.8） -<span style="font-weight: bold;">XX:MetaspaceSize</span> = 64m : 设置元空间初始值为64M</div><div>-<span style="font-weight: bold;">XX:ReservedCodeCacheSize</span>=128m 设置代码缓存区的大小（JIT编译后的都放在这里）</div><div>-<span style="font-weight: bold;">XX:NewRatio</span>=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</div><div>-<span style="font-weight: bold;">XX:SurvivorRatio</span>=8：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:8，即1个Survivor区占整个年轻代大小的1/10。</div><div>-<span style="font-weight: bold;">XX:MaxTenuringThreshold</span>=15 表示晋升到老年代的gc年龄，达到这个值就自动进入老年代，如果设置为0的话，表示不经过survivor区，直接进入到老年代</div><div>-<span style="font-weight: bold;">XX:PretenureSizeThreshold</span> = 0   表示晋升到老年代的对象大小，遇到超过这个值的对象，直接晋升到老年代（ <span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal;">PretenureSizeThreshold </span><span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-variant-caps: normal; font-variant-ligatures: normal;">参数只对Serial和ParNew两款收集器有效,  Parallel Scavenge 不识别这个参数</span>），默认值为0 时表示此条件不生效。</div><div><br/></div><div>两个疑问</div><div>1.class Demo{</div><div>        private static  Demo demo = new Demo();</div><div>}</div><div>类对象创建可以不等初始化完就可以进行</div><div>2.类名.class 这种用法有点像调用静态变量/方法  那么.class到底是什么用法，会触发类加载到第几步，可以肯定不会到初始化赋值那步。因为经过测试这样不会执行静态代码块。</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 