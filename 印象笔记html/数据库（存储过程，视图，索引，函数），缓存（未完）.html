<html>
<head>
  <title>数据库（存储过程，视图，索引，函数），缓存（未完）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600480 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="464"/>
<h1>数据库（存储过程，视图，索引，函数），缓存（未完）</h1>

<div>
<span><div>1.数据库事务特性：ACID</div><div><span style="font-size: 9pt;">⑴ 原子性（Atomicity）</span></div><div><span style="font-size: 9pt;">　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</span></div><div><span style="font-size: 9pt;">⑵ 一致性（Consistency）</span></div><div><span style="font-size: 9pt;">　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</span></div><div><span style="font-size: 9pt;">　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</span></div><div><span style="font-size: 9pt;">⑶ 隔离性（Isolation）</span></div><div><span style="font-size: 9pt;">　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</span></div><div><span style="font-size: 9pt;">　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</span></div><div><span style="font-size: 9pt;">　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</span></div><div><span style="font-size: 9pt;">⑷ 持久性（Durability）</span></div><div><span style="font-size: 9pt;">　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</span></div><div><span style="font-size: 9pt;">　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 9pt;">2.数据库隔离级别：</span></div><div>读未提交（Mongodb默认级别）</div><div><span style="font-size: 9pt;">读已提交（Oracle默认级别）-&gt;解决脏读问题</span></div><div><span style="font-size: 9pt;">可重读读（Mysql默认级别）-&gt;解决不可重复读问题，脏读</span></div><div><span style="font-size: 9pt;">串行化-&gt;解决不可重复读，脏读，换读</span></div><div><br/></div><div><span style="font-size: 9pt;">(1)Read UnCommitted 读未提交：</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 9pt; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">一个事务处理过程里读取了另一个未提交的事务中的数据;</span></div><div><span style="font-size: 9pt;">(2)Read Committed 读已提交：</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 9pt; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">一个事务处理过程只能读取了另一个已经提交的事务中的数据;                                           </span></div><div><span style="font-size: 9pt;">(3)Repeatable read 可重复读：一个事务处理过程中，多次读取数据，得到的结果始终一致，不受另一个事务提交的影响；</span></div><div><span style="font-size: 12px;">需要注意的是，可重复读，并没有阻止别的事物提交。</span></div><div><span style="font-size: 12px;"><b>原理分析：<a href="https://www.2cto.com/database/201807/763885.html" style="font-size: 9pt;">https://www.2cto.com/database/201807/763885.html</a></b></span></div><div><span style="font-size: 9pt;">         案例：</span><span style="font-size: 9pt;">假设一个事务是在记录A的字段为1的情况下才能插入记录B，然后事务首次查询A发现字段为1，于是下一步它准备插入记录B，但是在这个间隔的时候另外一个事务将A字段修改为了2</span></div><div><span style="font-size: 9pt;">(4)Serializable  串行化：   一个事务处理过程中，批量修改结果后，读取修改后的数据，不受另一个事务提交的影响； （个数不一样）解决：锁表？</span></div><div><br/></div><div><br/></div><div><br/></div><div>3.数据库锁机制</div><div>3.1.乐观锁：</div><div><span style="-en-paragraph:true;">乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。</span></div><div><span style="-en-paragraph:true;">通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。</span></div><div>乐观锁是是指判断是不是能获取锁的时机放到最后一刻。即先假设这个事情没问题，大概率能获得锁，然后先把数据改了。改完后要提交时再确定是不是有并发修改。对应悲观锁，是要改数据先抢锁，抢不到就不改。</div><div><br/></div><div>3.2.悲观锁 </div><div><span style="-en-paragraph:true;">与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</span></div><div><span style="-en-paragraph:true;">说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</span>   </div><div><br/></div><div>3.2.1锁的分类：</div><div>共享锁（Share锁，S锁，读锁）：事物在读取的时候，对数据库加锁，不允许其他事物对我要读取的数据进行update和delete；直到事务提交</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>--设置共享锁</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">SELECT … LOCK IN SHARE MODE;  </span></div></div><div><br/></div><div>3.2.2排他锁（ <span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial; font-variant-caps: normal; font-variant-ligatures: normal;">Exclusive</span>锁，X锁，互斥锁，写锁，独占锁）：事物在写的时候，对数据库加锁，既不允许其他事务读，也不允许其他事务去写，直到事物提交</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">--设置排他锁</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">SELECT … FOR UPDATE;</span></div></div><div><a href="http://blog.51cto.com/9291927/2096680">http://blog.51cto.com/9291927/2096680</a></div><div><br/></div><div>案例：</div><div>先查询a表字段值是否大于零，如果大于零，更新a表记录。</div><div>解决办法：把查询和修改放在一个事务里，查询时加共享锁，修改加独占锁，然后等事务提交时，既保证了读取时不被其他修改，也保证了修改时不被读取和修改。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>3.3.3行级锁：由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">比如共享锁语句</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SELECT * from city where id = &quot;1&quot;  lock in share mode;</div></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">由于对于city表中,id字段为主键，就也相当于索引。执行加锁时，会将id这个索引为1的记录加上锁，那么这个锁就是行锁。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">再比如排它锁语句</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>select * from Order where sn = &quot;00001&quot; for update</div></div><div><br/></div></div><div style="margin-top: 1em; margin-bottom: 1em;"><div><br/></div><div><br/></div></div><div><br/></div><div>3.3.4表级锁</div><div>MYSQL：不同存储引擎有不同区别。表锁有两种模式：表读锁和表写锁</div><div>a、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</div><div>b、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">--加表级读锁</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">lock tables table_name read local;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">--加表级写锁</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">lock tables table_name write;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">--释放所有表锁</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">unlock tables;</span></div></div><div>ORACLE :</div><div>行共享：允许用户进行任何操作，禁止排他锁</div><div>lock table person in row share mode;</div><div>行排他：允许用户进行任何操作，禁止共享锁</div><div>lock table person in row exclusive mode;</div><div>共享锁：其他用户只能看，不能修改</div><div>lock table person in share mode;</div><div>共享行排他：比共享锁有更多限制</div><div>lock table person in share row exclusive mode;</div><div>排他锁：其他用户只能看，不能修改，不能加其他锁</div><div>lock table person in exclusive mode;</div><div><a href="https://www.cnblogs.com/huangye-dream/archive/2013/07/06/3174725.html">https://www.cnblogs.com/huangye-dream/archive/2013/07/06/3174725.html</a></div><div><br/></div><div><br/></div><div><br/></div><div>4.事物隔离级别实现与锁机制：</div><div>一般来说：</div><div>支持MVCC的数据库，一般就用MVCC+锁实现了RR + RC</div><div>不支持MVCC的数据库，就是用锁实现了（北京liufor 442902149）</div><div><a href="http://www.cnblogs.com/wajika/p/6680200.html">http://www.cnblogs.com/wajika/p/6680200.html</a></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>5.死锁问题</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>数据库事务参考博客<a href="https://www.cnblogs.com/fjdingsd/p/5273008.html" style="font-size: 9pt;">https://www.cnblogs.com/fjdingsd/p/5273008.html</a></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 